function candidate=mmh(array,proportion,nonneg)
%Usage: candidate=mmh(array)
%Or: candidate=mmh(array,proportion)
%Or: candidate=mmh(array,proportion,nonneg)
%This function takes an array ('array') and returns a new array ('candidate') of the same size whose elements are drawn from a normal distribution centered around  the values in array.
%The calculation is similar to that used in a Metropolis-Hastings random walk. The elements in 'candidate' satisfy the reversibility condition, but the sampling is not from a stationary distribution and there is no optimization to an objective function.
%The standard deviation of the normal distribution can be specified using 'proportion'. If no value is specified, the standard deviation is set to 0.1 of the current 'array' value.
%Passing a value of 1 for the third argument automatically rejects 'candidate' values that are negative. If no third argument is used (or is a number other than 1), then negative values are allowed.
%To use, pass in an array ('array') that satisfies your model criteria. If the 'candidate' array generated by this function satisfies your model specific criteria, then pass in 'candidate' as 'array' to generate the next parameter set. If 'candidate' does not staisfy your model criteria, pass in the previous parameter set (here 'array') to generate a new candidate set.



	%default settings: if no proportion provided set it to 0.1 and assume parameters can be negative
	if(nargin==1)
		proportion=0.1;
		nonneg=0;
	elseif(nargin==2)
		nonneg=0;
	end

	array_size=max(size(array));
	for i=1:array_size
		%generate ith element in candidate array using normal distribution centered around current value
		candidate(i)=normrnd(array(i),proportion*array(i));
		if(nonneg==1 && candidate(i)<0) %check if non-negative values are not allowed
			candidate(i)=array(i); 
		else
			%reversibility condition
			pxi=1/(sqrt(2*pi)*proportion*array(i)); 
			qxi=1/(sqrt(2*pi)*proportion*array(i))*exp(-(candidate(i)-array(i))*(candidate(i)-array(i))/(2*(proportion*array(i))*(proportion*array(i))));
			
			pxip1=1/(sqrt(2*pi)*proportion*candidate(i)); 
			qxip1=1/(sqrt(2*pi)*proportion*candidate(i))*exp(-(array(i)-candidate(i))*(array(i)-candidate(i))/(2*(proportion*candidate(i))*(proportion*candidate(i))));
			num_rand=rand;
			
			if (num_rand>(pxip1*qxip1)/(pxi*qxi))
				candidate(i)=array(i);
			end
		end


	end


	

